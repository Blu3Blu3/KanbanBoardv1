// Y'know, looking back, I should've tried building this with React or Angular to make things a little more efficient in terms of operation and readability here.
// Then again, it should be fine. Plus setting up a whole React app might be difficult on PythonAnywhere.

const windowWidth = window.innerWidth;
const windowHeight =  window.innerHeight;
const scaleFactor = 8;

// Rows currently made. Starts at 0, and updates with maxTableDepth.
var numRows = 0;
// How "long" a column is, i.e., how many posts the column with the most posts has. This var can and will change with the board.
var maxTableDepth = 3;

var columnWidth = Math.round(windowWidth/scaleFactor);
// NOTE: Seems like there's a good middle ground if the denominator here is 4 - 5.5, but ideally there would be something that scales with the window's dimensions.
var rowHeight = Math.round(windowHeight/4);

// There is a Post array "queriedPosts" and a tableColumn array "queriedColumns" created in the HTML template, and you can still use them here. These following vars are built from them.
let queriedColumns;
let columnNames = [];
let columnDepths = [];
let numColumns = 0;
let queriedPosts;
let totalPosts;

// Static values
const priorityValues = ["Low", "Not Critical", "Normal", "High"];

// Tracked changes. These will be submitted when the "Submit Changes" button is clicked while this array is not empty.
// TO DO: Decide on a format for these. My initial thoughts are "Post" objects (ex. {id:1, name:"Posty McPostface", ..., tableColumn:"Ongoing", ...}) or query statements (ex. "ID(1), COLUMN(Completed), DEPTH(3)").
var changes = [];


// Post sorting parameters
// TO DO: Implement sorting by title, deadline, priority, and user.
// sortTypes denotes the possible filters for projects, sortBy becomes the filter chosen when a filter is made, and orderAsc is a boolean for whether or not the projects are sorted in ascending order or not.
const sortTypes = ["title", "deadline", "priority", "user"];
let sortBy = "";
let orderAsc = 0;



/* [][][] DEBUG [][][] */

// For when I'm messed up, homie, you're messed up...
function beAlright()
{
	console.log
	(
		"Right, here are your values:\n \
		Window width = " + windowWidth + "px\n \
		Window height = " + windowHeight + "px\n \
		Scale factor = " + scaleFactor + "\n \
		Column width = " + columnWidth + "px\n \
		Number of columns = " + numColumns + "\n \
		Row height = " + rowHeight + "px\n"
	);
	console.log
	(
		"THIS IS Not a number, why: Number of rows = " + numRows + "\n \
		Max posts in one column (Max table depth) = " + maxTableDepth-1 + "\n \
		Internal max table depth (includes blank posts) = " + maxTableDepth + "\n\n \
		Column names = " + columnNames + "\n \
		Column depths = " + columnDepths + "\n"
	);
	return;
}



/* [][][] INTERACTION [][][] */

// Called when posts are moved within the table.
// If going to a blank space after creation or once the page is loaded, insert all inner HTML into the space. If going to an occupied space, swap the inner HTML of both posts.
// If going between spaces, insert the inner HTML into the lower post space and move all other posts down.
// option = # of the option used (int), post = post being moved (HTML div) , postId = moving post space id, in the format "postSpace_x_y" (string), targetId = target post space id, in the format "postSpace_x_y" (string)
// TO DO: Make a way to update Post.lastDepth for each of the posts.
function processPost(option, post, postId, targetId)
{
    //console.log("PI = " + post.id + "   TI = " + targetId);
    let target = document.getElementById(targetId);
    let movingPost = post;
    //console.log("movingPost = " + movingPost)
    switch(option)
    {
        // Into a space
        case(0):
            console.log("target id " + targetId);
            //console.log("target first child id = " + target.firstChild.id);
            //console.log("target first child innerHTML = " + target.firstChild.innerHTML);
            if(target.firstChild.innerHTML == "")
            {
                console.log("Blank space: " + target.id);
                //console.log(movingPost.innerHTML);
                target.removeChild(target.firstChild);
                //After removing the first child, the target's inner HTML is guaranteed to be blank.
                movingPost.className += " interactablePost";
                target.appendChild(movingPost);
            }
            else
            {
                movingPost.className += " interactablePost";
                console.log("Swap spaces");
                //console.log(movingPost.innerHTML);
                //console.log(target.firstChild.innerHTML);
                let tempPost = document.createElement("table");
                tempPost.innerHTML = target.innerHTML;
                target.innerHTML = movingPost;
                document.getElementById(postId).innerHTML = tempPost.innerHTML;

                // Swap post ids too, though what you want to do eventually is to change the columns and set last depths.
                document.getElementById(postId).id = targetId;
                target.id = postId;
            }
            break;
        // Between posts (i.e., hitting the edges of the post space)
        // TO DO: This, but to be honest it can wait... focus on database submissions.
        case(1):
            if(target.className == "postSpace")
            {
                console.log("Between posts");
                target.firstChild.innerHTML = movingPost.innerHTML;
            }
            break;
        // Shouldn't fire, but just in case...
        default:
            console.log("ooooh it's defaulting oooooh");
            target.innerHTML = movingPost;
    }
    return;
}



/* [][][] TABLE CREATION [][][] */

// Set column width for all columns.
// className = HTML class name to target specific HTML elements (string)
function formatAsColumns(className)
{
	let boardColumns = document.getElementsByClassName(className);
	// Empty check
	if(boardColumns == null)
	{ return; }
	let result = 0;
	let capColumnsAt = scaleFactor;
	//console.log("Window width = " + windowWidth + " px");

	// If the board has 6+ columns, cap column width at 1/6 window width (6 by default).
	// This only works if the children elements (basically just the one for text) also change width.
	//console.log(totalBoardColumns >= capColumnsAt);
	if(numColumns >= capColumnsAt)
	{
		//console.log(boardColumns);
		let stringWidth = Math.round(100/scaleFactor);
		console.log("Calculated width = " + stringWidth + "% of " + windowWidth + " = " + stringWidth*windowWidth/100 + "px");
		for(let a=0; a<boardColumns.length; a++)
		{
			boardColumns[a].style.width = stringWidth + ("%");
			boardColumns[a].children[0].style.width = stringWidth + ("%");
		}
		result = Math.round(100/scaleFactor);
	}
	// Otherwise, set column width such that width is distributed evenly.
	else
	{
	    //console.log("Calculated width = " + 100/numColumns + "% of " + windowWidth + " = " + windowWidth/numColumns + "px");
	    // I don't know why setting this low gets things to work, but as long as it works I'm ok with it.
	    // Someday I'll fix this, probably by formatting the table headers and posts separately.
	    let width = 1;
		for(let a=0; a<boardColumns.length; a++)
		{
			//boardColumns[a].style.width = Math.round(windowWidth/numColumns) + "px";
			//boardColumns[a].children[0].style.width = Math.round(windowWidth/numColumns) + "px";

			// This controls the size of the column headers and the background post spaces.
			boardColumns[a].style.width = width + "%";
			//console.log(boardColumns[a].style.width);
			// This controls the size of the links and the post drag boxes.
			boardColumns[a].children[0].style.width = "85%";
		}
		result =  Math.round(100/numColumns);
	}
	// Saving the column width for future formatting...
	columnWidth = result;
	//console.log("Board columns formatted! Width = " + 100/numColumns + "% of " + windowWidth + " = " + windowWidth/numColumns + "px");
	return;
}

// Create a row for posts within the board table.
// This should be called whenever a post is dragged to a non-empty column that has the same amount of posts as the longest column.
function createPostRow()
{
	let newRow = document.createElement("tr");
	// Keep in mind that these are numbered starting from 0, rather than 1. It's caused some headache but everything's working fine.
	newRow.id = "row" + numRows;
	//console.log(newRow.id + "\n");
	//console.log("Making row #" + (numRows + 1) + "...");
	if(numRows >= maxTableDepth)
	{
		maxTableDepth++;
	}
	numRows++;
	newRow.style.height = rowHeight +"px";
	for(let a=0; a<numColumns; a++)
	{
		// Every post "space" has a blank div element to start, but it's only interactable if the space is the first in the column.
		// So, if you have columns of 1 & 4 posts respectively, the 1-post column will have 3 blank spaces, but only the first space, the one after the lone post, is interactable.
		let newPostSpace = document.createElement("td");
		let newPost = document.createElement("div");
		newPostSpace.className = "postSpace";
		newPostSpace.style.width = "100%";
		newPostSpace.style.height = rowHeight + "px";
		// TO DO: Check if this attribute is necessary; I'm not too sure it is since all the post divs are serialized now...
		newPostSpace.id = "postSpace_" + numRows + "_" + (a+1);
		newPost.className = "post";
		// If the row being built is the one right after a column's lowest post, also make the post space at that column and row interactable.
		if(numRows <= columnDepths[a]+1)
		{
		    newPost.className += " interactablePost";
		}
		newPost.style.width = "100%";
		newPost.style.height = Math.round(rowHeight*0.85) + "px";

        // Only fires if the column depths allow. So, if you want to add on to this, adjust columnDepths first.
		if(numRows <= columnDepths[a]+1)
		{
		    if (numRows == columnDepths[a] + 1) {console.log("Capping column " + columnNames[a] + " at row " + numRows);}
            newPostSpace.appendChild(newPost);
		    newRow.appendChild(newPostSpace);
		}
	}
	document.getElementById("board").appendChild(newRow);
	//console.log("Successfully added new blank row. Max table depth = " + maxTableDepth + "\n");
	return;
}

// Delete the last row within the board table, since there's no reason to delete any other row.
// This should only be called internally, and only when the last post in the longest column is deleted, moved to another column, or resolved.
function deletePostRow()
{
	let lastRowID = "row" + (maxTableDepth-1);
	let lastRow = document.getElementById(lastRowID);
	//console.log("lastRowID = " + lastRowID + "\n");
	//console.log("Row " + maxTableDepth + " acquired, locking on... Fire!");
	document.getElementById("board").removeChild(lastRow);
	//console.log("Target eliminated! " + maxTableDepth + " rows remain...");
	maxTableDepth--;
	numRows--;

	// This shouldn't fire anymore, but this would be a catch for discrepancies in row number...
	if(maxTableDepth != numRows)
	{ console.log("Something's fishy... " + maxTableDepth + " " + numRows + "\n"); }
	return;
}

// Remove all posts from the board and the database. This should be an internal function, maybe accessible from settings.
function clearAllPosts()
{
	for(let a = numRows; a > 0; a--)
	{
		deletePostRow();
	}
	console.log("All posts cleared from board.\n");
	// TO DO: Figure out post back-end... but later.

	return;
}

// TO DO: This!
// Double-check the data input in a form (i.e., just the post creation form for now (2/20/2025)) to ensure that it's fine to add to the database.
// Namely, this ensures that ranged values make sense, and names are sanitized.
function validateForm()
{
    // Ooops that's not very secure haha
    for(let a = 0; a < document.forms["creationForm"].length; a++)
    {
        console.log(document.forms["creationForm"][a] + "&emsp;" + document.forms["creationForm"][a].value);
    }
    console.log("gwahahaha boo!");
    return;
}

// Scrapped for now (2/19/2025), because there are really only ~3 columns needed.
/* Create a new column within the board table.
// This should be called whenever the "New Column" button is clicked and the necessary prompts are answered.
function createColumn()
{
	return;
}

// Delete a column within the board table.
// This should be called whenever the "Delete Column" button is clicked and the necessary prompts are answered.
// Columns can be non-empty.
function deleteColumn()
{
	return;
}
*/

// Makes a given element invisible and intangible. OoOoOo, it's a ghooost.
// id = DOM ID of HTML element (string)
function hideThis(id)
{
    var ele = document.getElementById(id);
    if(ele != null)
    {
        ele.style.display = "none";
    }
    return;
}

// Builds a new post from the queried data, then assigns it to a given post space depending on column and sorting conditions.
// postValues = post values from table "post" (Post object)
// Return = an HTML div element under the class "post", id "post_id", where "id" is postValues.id
// TO DO: Figure out sorting conditions. It's likely that you'll use the URL request in conjunction with
function createPost(postValues)
{
    // Create a div that'll house the contents of the target post, style it like the blank posts, and then place it in the table as per given conditions.
    // Current post layout has a half-and-half or 2/3-and-1/3 set up, with the left side holding title and tasks, and the right side holding priority, deadline, and users.
    // All the elements should be relative to their parent divs.

    // Get target post from queried posts

    let post = postValues;
    let postId = post.id;
    console.log("In createPost: " + post + "\n" + postId);

    // Post base + post columns
    let postBase = document.createElement("table");
    postBase.style.width = "100%";
    postBase.style.height = "100%";
    postBase.style.border = "3px black solid";
    postBase.style.borderRadius = "15px";
    postBase.style.verticalAlign = "text-top";
    postBase.className = "post interactablePost";
    postBase.id = "post_" + postId;

    let postRow1 = document.createElement("tr");
    postRow1.style.maxHeight = "30%";
    let titleSpace = document.createElement("th");
    titleSpace.style.width = "100%";
    titleSpace.style.overflow = "auto";
    titleSpace.colspan = "2";
    titleSpace.backgroundColor = "#FFFFFF";
    let prioritySpace = document.createElement("th");
    prioritySpace.style.width = "33%";
    prioritySpace.style.borderRadius = "15px";
    postRow1.appendChild(titleSpace);
    postRow1.appendChild(prioritySpace);


    // TO DO: Fix this please!
    let postRow2 = document.createElement("tr");
    postRow2.style.height = "50%";
    postRow2.style.maxHeight = "30%";
    let taskSpace = document.createElement("td");
    taskSpace.colspan = "2";
    let deadlineSpace = document.createElement("td");
    deadlineSpace.style.width = "33%";
    postRow2.appendChild(taskSpace);
    postRow2.appendChild(deadlineSpace);

    let postRow3 = document.createElement("tr");
    postRow3.style.height = "20%";
    postRow3.style.paddingBottom = "15px";
    let userSpace = document.createElement("td");
    userSpace.colspan = "3";
    userSpace.style.textAlign = "center";
    userSpace.style.borderRadius = "15px";
    postRow3.appendChild(userSpace);


    // Post elements
    let postTitle = document.createElement("h1");
    postTitle.name = postBase.id + "_title";
    postTitle.style.width = "100%";
    postTitle.style.height = "50%";
    postTitle.style.fontSize = "125%";
    postTitle.style.overflow = "hidden";
    postTitle.style.overflowWrap = "break-word";
    postTitle.style.textDecoration = "underline";
    postTitle.innerHTML = post.title;

    let postTasks = document.createElement("p");
    postTasks.name = postBase.id + "_tasks";
    postTasks.style.textAlign = "center";
    postTasks.style.display = "block";
    postTasks.style.top = "0px";
    postTasks.style.verticalAlign = "text-top";
    postTasks.style.border = "2px solid pink";
    postTasks.style.borderRadius = "15px";
    // Truncate long tasks
    if(post.tasks.length >= 96)
    {
        //postTasks.style.backgroundColor = "orchid";
        let cutTasks = post.tasks.substring(0, 96);
        cutTasks = cutTasks.substring(0, cutTasks.lastIndexOf(' ')) + "...";
        postTasks.innerHTML = cutTasks;
    }
    else
    {
        postTasks.innerHTML = post.tasks;
    }

    let postPriority = document.createElement("span");
    postPriority.name = postBase.id + "_priority";
    postPriority.style.width = "100%";
    postPriority.style.textAlign = "center";
    postPriority.style.fontSize = "90%";
    postPriority.innerHTML = "Priority:\n";

    switch(post.priority)
    {
        case(0):
            postPriority.innerHTML += "Low";
            prioritySpace.style.backgroundColor = "#7becf1";
            break;
        case(1):
            postPriority.innerHTML += "\nNot Critical";
            prioritySpace.style.backgroundColor = "#97a6f4";
            break;
        case(2):
            postPriority.innerHTML += "Normal";
            prioritySpace.style.backgroundColor = "#c0c0c0";
            break;
        case(3):
            postPriority.innerHTML += "High";
            prioritySpace.style.backgroundColor = "#fab166";
            break;
        default:
            postPriority.innerHTML += "Low";
            prioritySpace.style.backgroundColor = "#c0c0c0";
            break;
    }

    let postDeadline = document.createElement("p");
    postDeadline.name = postBase.id + "_deadline";
    postDeadline.style.width = "100%";
    postDeadline.style.height = "20%";
    postDeadline.style.top = "0px";
    postDeadline.style.borderRadius = "15px";
    postDeadline.innerHTML = "Due by:&#10;" + post.deadline.substring(0, post.deadline.lastIndexOf(','));

    let postUserBase = document.createElement("div");
    postUserBase.name = postBase.id + "_userBase";
    postUserBase.style.textAlign = "center";
    postUserBase.innerHTML = "Who's Responsible:  " + post.taggedUser;

    // TO DO: Add a button to "Edit Post", just like you have a button here to access "Post Settings".
    //let postSettings = document.createElement("img");

    // Creating the final div
    titleSpace.appendChild(postTitle);
    prioritySpace.appendChild(postPriority);
    taskSpace.appendChild(postTasks);
    deadlineSpace.appendChild(postDeadline);
    userSpace.appendChild(postUserBase);

    postBase.appendChild(postRow1);
    postBase.appendChild(postRow2);
    postBase.appendChild(postRow3);

    return postBase;
}

// Deletes the post this is called for, removing it from the board and from the database.
// TO DO: It'd be neat if there was a recycle bin for this, like a separate table where deleted posts move to in the DB. They'd expire after 3 days or so.
// NOTE: To do this, it'd be best to handle the deletion (like all other database things aside from form submission) in Flask.
function deletePost(postID)
{
    alert("Oh no!");
    return;
}

// Creates a document body element that darkens the screen. Meant to be used with prompt windows.
// There were a lot of spots where the same creation code was, so this function was made for better readability.
function createDarkFilter()
{
    if(document.getElementById("darkFilter") == null)
	{
	    console.log("Dark filter does not exist; creating now...")

	    let darkFilter = document.createElement("div");
	    darkFilter.class = "filter";
	    darkFilter.id = "darkFilter";

	    // Styling the background
	    darkFilter.style.display = "none";
	    darkFilter.style.zIndex = "1";
	    darkFilter.style.width = "100%";
	    darkFilter.style.height = "100%";
	    darkFilter.style.left = 0;
	    darkFilter.style.top = 0;
	    darkFilter.style.position = "fixed";
	    darkFilter.style.overflow = "auto";
	    darkFilter.style.backgroundColor = "black";
	    darkFilter.style.opacity = "0.5";
	    darkFilter.onclick = () => {
	        hideThis("darkFilter");
	        hideThis("creationWindow");
	        hideThis("filterWindow");
	        hideThis("summarizeWindow");
	        hideThis("helpWindow");
	        hideThis("postWindow");
	    };

	    document.body.appendChild(darkFilter);
	}
}

// Adds CSS styling to a form window / modal, since just adding a class with styling in the CSS file doesn't seem to work.
// aWindow = The window to stylize (HTML element (div))
function stylizeWindow(aWindow)
{
    aWindow.style.display = "none";
    aWindow.style.position = "fixed";
    aWindow.style.width = "50%";
    aWindow.style.height = "auto";
    aWindow.style.lineHeight = "2";
    aWindow.style.textAlign = "center";
    aWindow.style.margin = "auto";
    aWindow.style.top = "25%";
    aWindow.style.left = "25%";
    aWindow.style.paddingBottom = "20px";
    aWindow.style.backgroundColor = "white";
    aWindow.style.border = "2px solid #888";
    aWindow.style.zIndex = "1";
}

// Get a Post object from queriedPosts given the post's id, which itself is just an int.
function getPost(id)
{
    for(let p of queriedPosts)
    {
        if(p.id == id)
        {
            return p;
        }
    }
    return null;
}


// Brings up the post creation modal for whichever column this function was called from. It can be cancelled with the "Cancel" button or by clicking off the modal.
// Submitting posts the inputs to the database and refreshes the site.
// name = Name of the column the post will be added under (string)
// ALL GOOD!
function promptPost(name)
{
	console.log("Making a new post under: " + name + "\n");

	// If the creation window and background haven't been made yet, make them, then reveal them after they're completed.
	// Apparently these windows are called "modals"! I'm not going to change the names here, but that's still something new.

	createDarkFilter();

	if(document.getElementById("creationWindow") == null)
	{
	    console.log("Creation window does not exist; creating now...");

	    // Window base
	    let creationWindow = document.createElement("div");
	    creationWindow.id = "creationWindow";
	    document.body.appendChild(creationWindow);
	    //console.log(document.getElementById("creationWindow"));
	    let creationForm = document.createElement("form");
	    creationForm.action = ".";
	    creationForm.method = "POST";
	    creationForm.name = "creationForm";
	    creationForm.id = "creationForm";
	    // what's this?
	    Object.defineProperty(document, "referrer", {post: function(){return "https://www.pythonanywhere.com/user/CGuiangInPain/files/home/CGuiangInPain/mysite/templates/Test HTML Kanban Board v2.html"}});
	    creationForm.onsubmit = "validateForm()";

	    // Form title
	    let creationTitle = document.createElement("h1");
	    creationTitle.id = "creationTitle";
	    creationTitle.style.fontSize = "30px";
	    creationTitle.style.textDecoration = "underline";
	    creationTitle.innerHTML = "New Post into: " + name;


	    // Input fields + labels
	    let titleInput = document.createElement("input");
	    titleInput.type = "text";
	    titleInput.id = "postTitle";
	    titleInput.name = "postTitle";
	    titleInput.required = "true";
	    let titleLabel = document.createElement("label");
	    titleLabel.for = titleInput.id;
	    titleLabel.innerHTML = "<span class=\"highlightBad\">*</span> Title:&emsp;";

	    let priorityInputs = [];

	    let priorityLabel = document.createElement("label");
	    for(let a = 0; a < 4; a++)
	    {
	        let newRadio = document.createElement("input");
	        newRadio.type = "radio";
	        newRadio.name = "postPriority";
	        newRadio.id = "postPriority" + a;
	        newRadio.value = a;
	        newRadio.required = "true";

	        let newRadioLabel = document.createElement("label");
	        newRadioLabel.for = newRadio.id;
	        newRadioLabel.innerHTML = "&emsp;" + priorityValues[a] + "  ";

	        priorityInputs.push(newRadioLabel);
	        priorityInputs.push(newRadio);
	    }
	    console.log(priorityInputs.length);
	    priorityLabel.for = "postPriority0";
	    priorityLabel.innerHTML = "<span class=\"highlightBad\">*</span> Priority:&emsp;";

	    let taskInput = document.createElement("textarea");
	    taskInput.id = "postTask";
	    taskInput.name = "postTask";
	    taskInput.required = "true";
	    let taskLabel = document.createElement("label");
	    taskLabel.for = taskInput.id;
	    taskLabel.innerHTML = "<span class=\"highlightBad\">*</span> Tasks:&emsp;";

	    let deadlineInput = document.createElement("input");
	    deadlineInput.type = "date";
	    deadlineInput.name = "postDeadline";
	    let deadlineLabel = document.createElement("label");
	    deadlineLabel.innerHTML = "Due on: ";

        // TO DO: Implement a system for multiple users to be responsible for a project.
	    let userInput = document.createElement("input");
	    userInput.type = "text";
	    userInput.id = "postUser";
	    userInput.name = "postUser";
	    userInput.required = "true";
	    let userLabel = document.createElement("label");
	    userLabel.for = userInput.id;
	    userLabel.innerHTML = "<span class=\"highlightBad\">*</span> Who's in charge of this?&emsp;";

	    let columnInput = document.createElement("input");
	    columnInput.value = name;
	    columnInput.type = "hidden";
	    columnInput.id = "postColumn";
	    columnInput.name = "postColumn";

	    let depthInput = document.createElement("input");
	    depthInput.value = columnDepths[columnNames.indexOf(name)] + 1;
	    depthInput.type = "hidden";
	    depthInput.id = "postDepth";
	    depthInput.name = "postDepth";

	    let submitInput = document.createElement("input");
	    submitInput.name = "creationSubmit";
	    submitInput.type = "submit";
	    submitInput.value = "Submit";
	    submitInput.onclick = "validateForm()";

	    let resetInput = document.createElement("input");
	    resetInput.type = "reset";
	    resetInput.value = "Reset";

	    // Styling the window
	    creationWindow.class = "window";
	    stylizeWindow(creationWindow);

	    // Appending and styling the elements within the window
	    creationForm.appendChild(creationTitle);
	    creationForm.appendChild(titleLabel);
	    creationForm.appendChild(titleInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(priorityLabel);
	    for(let b = 0; b < priorityInputs.length; b++)
	    {
	        creationForm.appendChild(priorityInputs[b]);
	    }
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(taskLabel);
	    creationForm.appendChild(taskInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(deadlineLabel);
	    creationForm.appendChild(deadlineInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(userLabel);
	    creationForm.appendChild(userInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(columnInput);
	    creationForm.appendChild(depthInput);
	    creationForm.appendChild(submitInput);
	    creationForm.appendChild(resetInput);

	    creationWindow.appendChild(creationForm);
	    //document.body.appendChild(creationWindow);
	}

    //console.log(document.getElementById("creationWindow"));
    //console.log(document.getElementById("darkFilter"));

    // Reveal the window
    document.getElementById("darkFilter").style.display = "block";
    creationWindow.className = "window";
    // creationForm.style.display = "block";
    document.getElementById("creationTitle").innerHTML = "New Post into: " + name;
	document.getElementById("creationWindow").style.display = "block";

	return;
}

// Edits a post using the input credentials.
// This is mostly identical to promptPost(), only adding an id parameter as a hidden input and changing a few bits of text to be about editing, rather than creating a post.
// id = ID of the post (i.e., post.id) (int), name = name of the column the post is under (i.e., post.tableColumn)
// TO DO: Adjust these entry fields to reflect the current values of the post, so the user has something to work off of when editing. Also tweak Flask if need be.
function editPost(id, name)
{
    // Get post first...
    try
    {
        let post = getPost(id);
        if(post == null)
        {
            throw "No post";
        }
    }
    catch(err)
    {
        alert("The post you're trying to get with id \"" + id + "\" is null. Stopping here...");
        return;
    }

    console.log("post = " + post);

	console.log("Editing post #" + id + ", which is under: " + name + "\n");

	createDarkFilter();

	if(document.getElementById("creationWindow") == null)
	{
	    console.log("Creation window does not exist; creating now...");

	    // Window base
	    let creationWindow = document.createElement("div");
	    creationWindow.id = "creationWindow";
	    document.body.appendChild(creationWindow);
	    //console.log(document.getElementById("creationWindow"));
	    let creationForm = document.createElement("form");
	    creationForm.action = ".";
	    creationForm.method = "POST";
	    creationForm.name = "creationForm";
	    creationForm.id = "creationForm";
	    // what's this?
	    Object.defineProperty(document, "referrer", {post: function(){return "https://www.pythonanywhere.com/user/CGuiangInPain/files/home/CGuiangInPain/mysite/templates/Test HTML Kanban Board v2.html"}});
	    creationForm.onsubmit = "validateForm()";

	    // Form title
	    let creationTitle = document.createElement("h1");
	    creationTitle.id = "creationTitle";
	    creationTitle.style.fontSize = "30px";
	    creationTitle.style.textDecoration = "underline";
	    creationTitle.innerHTML = "Editing project #" + id;


	    // Input fields + labels
	    let titleInput = document.createElement("input");
	    titleInput.type = "text";
	    titleInput.id = "postTitle";
	    titleInput.name = "postTitle";
	    titleInput.value = post.title;
	    titleInput.required = "true";
	    let titleLabel = document.createElement("label");
	    titleLabel.for = titleInput.id;
	    titleLabel.innerHTML = "<span class=\"highlightBad\">*</span> Title:&emsp;";

	    let priorityInputs = [];

	    let priorityLabel = document.createElement("label");
	    for(let a = 0; a < 4; a++)
	    {
	        let newRadio = document.createElement("input");
	        newRadio.type = "radio";
	        newRadio.name = "postPriority";
	        newRadio.id = "postPriority" + a;
	        newRadio.value = a;
	        if(a == post.priority)
	        {
	            // element.checked is a bool, so this should work...
	            newRadio.checked = 1;
	        }
	        newRadio.required = "true";

	        let newRadioLabel = document.createElement("label");
	        newRadioLabel.for = newRadio.id;
	        newRadioLabel.innerHTML = "&emsp;" + priorityValues[a] + "  ";

	        priorityInputs.push(newRadioLabel);
	        priorityInputs.push(newRadio);
	    }
	    console.log(priorityInputs.length);
	    priorityLabel.for = "postPriority0";
	    priorityLabel.innerHTML = "<span class=\"highlightBad\">*</span> Priority:&emsp;";

	    let taskInput = document.createElement("textarea");
	    taskInput.id = "postTask";
	    taskInput.name = "postTask";
	    taskInput.value = post.tasks;
	    taskInput.required = "true";
	    let taskLabel = document.createElement("label");
	    taskLabel.for = taskInput.id;
	    taskLabel.innerHTML = "<span class=\"highlightBad\">*</span> Tasks:&emsp;";

	    let deadlineInput = document.createElement("input");
	    deadlineInput.type = "date";
	    deadlineInput.name = "postDeadline";
	    deadlineInput.value = post.deadline;
	    let deadlineLabel = document.createElement("label");
	    deadlineLabel.innerHTML = "Due on: ";

	    let userInput = document.createElement("input");
	    userInput.type = "text";
	    userInput.id = "postUser";
	    userInput.name = "postUser";
	    userInput.value = post.taggedUser;
	    userInput.required = "true";
	    let userLabel = document.createElement("label");
	    userLabel.for = userInput.id;
	    userLabel.innerHTML = "<span class=\"highlightBad\">*</span> Who's in charge of this?&emsp;";

        // TO DO: Add the ability to change column from this function. In other words, add a dropdown here.
	    let columnInput = document.createElement("input");
	    columnInput.value = name;
	    columnInput.type = "hidden";
	    columnInput.id = "postColumn";
	    columnInput.name = "postColumn";

	    let depthInput = document.createElement("input");
	    depthInput.value = columnDepths[columnNames.indexOf(name)] + 1;
	    depthInput.type = "hidden";
	    depthInput.id = "postDepth";
	    depthInput.name = "postDepth";

	    let submitInput = document.createElement("input");
	    submitInput.name = "creationSubmit";
	    submitInput.type = "submit";
	    submitInput.value = "Submit";
	    submitInput.onclick = "validateForm()";

	    let resetInput = document.createElement("input");
	    resetInput.type = "reset";
	    resetInput.value = "Reset";

	    // Styling the window
	    creationWindow.class = "window";
	    stylizeWindow(creationWindow);

	    // Appending and styling the elements within the window
	    creationForm.appendChild(creationTitle);
	    creationForm.appendChild(titleLabel);
	    creationForm.appendChild(titleInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(priorityLabel);
	    for(let b = 0; b < priorityInputs.length; b++)
	    {
	        creationForm.appendChild(priorityInputs[b]);
	    }
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(taskLabel);
	    creationForm.appendChild(taskInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(deadlineLabel);
	    creationForm.appendChild(deadlineInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(userLabel);
	    creationForm.appendChild(userInput);
	    creationForm.appendChild(document.createElement("br"));
	    creationForm.appendChild(columnInput);
	    creationForm.appendChild(depthInput);
	    creationForm.appendChild(submitInput);
	    creationForm.appendChild(resetInput);

	    creationWindow.appendChild(creationForm);
	    //document.body.appendChild(creationWindow);
	}

	// If "creationWindow" already exists and is populated, update the entries inside to reflect the existing values of the post.
	document.getElementById("postTitle").value = post.title;
	document.getElementById("postPriority" + post.priority).checked = 1;
	document.getElementById("postTask").value = post.tasks;
	document.getElementById("postDeadline").value = post.deadline;
	document.getElementById("postUser").value = post.taggedUser;

    //console.log(document.getElementById("creationWindow"));
    //console.log(document.getElementById("darkFilter"));

    // Reveal the window
    document.getElementById("darkFilter").style.display = "block";
    creationWindow.className = "window";
    document.getElementById("creationTitle").innerHTML = "Editing Post #" + lastDepth + " of " + name;
	document.getElementById("creationWindow").style.display = "block";

	return;
}

// Brings up a filter menu to allow for post sorting.
// ALL GOOD!
function filterTable()
{
    console.log("Entering some new filters?");

    createDarkFilter();

	if(document.getElementById("filterWindow") == null)
	{
	    // Window base
	    let filterWindow = document.createElement("div");
	    filterWindow.id = "filterWindow";
	    document.body.appendChild(filterWindow);
	    let filterForm = document.createElement("form");
	    filterForm.action = ".";
	    filterForm.method = "POST";
	    filterForm.name = "filterForm";
	    // what's this?
	    Object.defineProperty(document, "referrer", {post: function(){return "https://www.pythonanywhere.com/user/CGuiangInPain/files/home/CGuiangInPain/mysite/templates/Test HTML Kanban Board v2.html"}});

	    // Form title
	    let filterTitle = document.createElement("h1");
	    filterTitle.id = "filterTitle";
	    filterTitle.style.fontSize = "30px";
	    filterTitle.style.textDecoration = "underline";
	    filterTitle.innerHTML = "Filters";

	    // Form inputs
	    let typeInputs = [];
	    const typeValues = ["Title", "Priority", "Tasks", "Deadline", "User"]
	    let typeLabel = document.createElement("label");
	    typeLabel.id = "typeLabel";
	    typeLabel.innerHTML = "Sort by:&emsp;";
	    for(let a = 0; a < typeValues.length; a++)
	    {
	        let newRadio = document.createElement("input");
	        newRadio.type = "radio";
	        newRadio.name = "filterType";
	        newRadio.id = "filterType" + a;
	        newRadio.value = typeValues[a];

	        let newRadioLabel = document.createElement("label");
	        newRadioLabel.for = newRadio.id;
	        newRadioLabel.innerHTML = "&emsp;" + typeValues[a] + "  ";

	        typeInputs.push(newRadioLabel);
	        typeInputs.push(newRadio);
	    }
	    typeLabel.for = "filterType0";

	    let orderInput = document.createElement("input");
	    orderInput.type = "checkbox";
	    orderInput.name = "filterOrder";
	    orderInput.id = "filterOrder";
	    //orderInput.checked = "false";
	    orderInput.value = 1;
	    let orderLabel = document.createElement("label");
	    orderLabel.id = "orderLabel";
	    orderLabel.innerHTML = "Use descending order:&emsp;";
	    orderLabel.for = "filterOrder";

	    let submitInput = document.createElement("input");
	    submitInput.name = "filterSubmit";
	    submitInput.type = "submit";
	    submitInput.value = "Submit";
	    submitInput.onclick = "validateForm()";

	    let resetInput = document.createElement("input");
	    resetInput.type = "reset";
	    resetInput.value = "Reset";

	    // Create window
	    filterForm.appendChild(filterTitle);
	    //filterForm.appendChild(document.createElement("br"));
	    filterForm.appendChild(typeLabel);
	    for(let b = 0; b < typeInputs.length; b++)
	    {
	        filterForm.appendChild(typeInputs[b]);
	    }
	    filterForm.appendChild(document.createElement("br"));
	    filterForm.appendChild(orderLabel);
	    filterForm.appendChild(orderInput);
	    filterForm.appendChild(document.createElement("br"));
	    filterForm.appendChild(submitInput);
	    filterForm.appendChild(resetInput);

	    filterWindow.className = "window";
	    stylizeWindow(filterWindow);
	    filterWindow.appendChild(filterForm);

	}

	// Show the window
	document.getElementById("darkFilter").style.display = "block";
	document.getElementById("filterWindow").style.display = "block";

	return;
}

// Creates a summary of posted projects, bringing up anomalies and notable points about any given project.
function summarizeTable()
{
    createDarkFilter();

    if(document.getElementById("summarizeWindow") == null)
    {
        // Window base
	    let summarizeWindow = document.createElement("div");
	    summarizeWindow.id = "summarizeWindow";
	    document.body.appendChild(summarizeWindow);

	    // Window title
	    let summarizeTitle = document.createElement("h1");
	    summarizeTitle.id = "summarizeTitle";
	    summarizeTitle.style.fontSize = "30px";
	    summarizeTitle.style.textDecoration = "underline";
	    summarizeTitle.innerHTML = "Things to Note";

	    // Anomalous materials (ex. overdue projects, counts of projects under specific users or priorities, etc.)
	    let summarizeList = document.createElement("ul");
	    let prioritiesTable = document.createElement("table");
	    let prioritiesTableHeader = document.createElement("tr");
	    let priorityHeader = document.createElement("th");
	    priorityHeader.colspan = "4";
	    priorityHeader.style.textAlign = "center";
        priorityHeader.innerHTML = "Projects per Priority";
        prioritiesTableHeader.appendChild(priorityHeader);
        prioritiesTable.appendChild(prioritiesTableHeader);
	    let usersTable = document.createElement("table");
	    let usersTableHeader = document.createElement("tr");
	    let userHeader = document.createElement("th");
	    userHeader.colspan = "6";
	    userHeader.style.textAlign = "center";
        userHeader.innerHTML = "Projects per User";
        usersTableHeader.appendChild(userHeader);
        usersTable.appendChild(usersTableHeader);

	    summarizeList.style.textAlign = "left";
	    //summarizeList.style.marginLeft = "10%";
	    summarizeList.style.listStylePosition = "inside";

	    prioritiesTable.style.borderRadius = "15px";
	    prioritiesTable.style.border = "2px solid pink";
	    prioritiesTable.style.marginTop = "5%";
	    prioritiesTable.style.marginLeft = "25%";
	    prioritiesTable.style.width = "50%";

	    usersTable.style.borderRadius = "15px";
	    usersTable.style.border = "2px solid pink";
	    usersTable.style.marginTop = "5%";
	    usersTable.style.marginLeft = "10%";
	    usersTable.style.width = "80%";

	    let postPrioritiesCounts = [0, 0, 0, 0];
	    let postUsers = [];
	    let postUsersCounts = [];
	    let upcomingPosts = 0;

	    for(let post of queriedPosts)
	    {
	        let postDate = post.deadline.slice(0, post.deadline.indexOf(','));
	        postDate = new Date(postDate);
	        let currentDate = new Date();

	        // Priority check (Accumulate total amounts of posts in each priority, and post them as plain counts. Raise an anomaly later if there are 3+ high priority posts.)
            postPrioritiesCounts[post.priority]++;

	        // User check (Accumulate total amounts of posts from each user, and post them as plain counts. Raise an anomaly later if there are 3+ posts under one person.)
	        console.log("Post user = " + post.taggedUser);
	        if(postUsers.indexOf(post.taggedUser) == -1)
	        {
	            postUsers.push(post.taggedUser);
	            postUsersCounts.push(1);
	        }
	        else
	        {
	            postUsersCounts[postUsers.indexOf(post.taggedUser)] += 1;
	        }

	        /*console.log("yehaw\n" + typeof(postDate));
	        console.log(postDate);
	        console.log(currentDate);
	        console.log(postDate.getYear());
	        console.log(currentDate.getYear());
	        console.log(postDate.getMonth());
	        console.log(currentDate.getMonth());*/

	        let anomaly = document.createElement("li");

	        // Deadline check
	        // If the deadline is past the current year, don't even bother checking the rest.
	        if(postDate.getYear() > currentDate.getYear())
	        {
	            continue;
	        }
	        // If the deadline is in the same year, check months.
	        else if (postDate.getYear() == currentDate.getYear())
	        {
	            // If the deadline is past the current month, only warn if it's in the next month.
	            if(postDate.getMonth() > currentDate.getMonth())
	            {
	                if((currentDate.getMonth - postDate.getMonth()) == 1)
	                {
	                    anomaly.innerHTML = "Project #" + post.lastDepth + " in " + post.tableColumn + ":&emsp;<span class=\"highlightGood\">Just a heads up, this comes up next month.</span>";
	                    upcomingPosts++;
	                }
	            }
	            // If in the same month, check days.
	            else if (postDate.getMonth() == currentDate.getMonth())
	            {
	                if(postDate.getDate() > currentDate.getDate())
	                {
	                    anomaly.innerHTML = "Project #" + post.lastDepth + " in " + post.tableColumn + ":&emsp;<span class=\"highlightGood\">Due in " + (postDate.getDate()-currentDate.getDate()) + " days.</span>";
	                    upcomingPosts++;
	                }
	                else if (postDate.getDate() == currentDate.getDate())
	                {
	                    anomaly.innerHTML = "Project #" + post.lastDepth + " in " + post.tableColumn + ":&emsp;<span class=\"highlightGood\">Due today!</span>";
	                    upcomingPosts++;
	                }
	                else
	                {
	                    anomaly.innerHTML = "Project #" + post.lastDepth + " in " + post.tableColumn + ":&emsp;<span class=\"highlightBad\">Overdue by " + (currentDate.getDate()-postDate.getDate()) + " days.</span>";
	                }
	            }
	            else
	            {
	                let monthDiff = Math.abs(postDate.getMonth() - currentDate.getMonth());
	                console.log(postDate);
	                console.log("monthDiff = " + monthDiff);
	                anomaly.innerHTML = "Project #" + post.lastDepth + " in " + post.tableColumn + ":&emsp;<span class=\"highlightBad\">Overdue by " + (currentDate.getMonth()-postDate.getMonth()) + " month";
	                if(monthDiff == 1) { anomaly.innerHTML += "<span class=\"highlightBad\">.</span>"; }
	                else { anomaly.innerHTML += "<span class=\"highlightBad\">s.</span>"; }
	            }
	        }
	        else
	        {
	            let monthDiff = (12 * (currentDate.getYear() - postDate.getYear() - 1)) + (12 - postDate.getMonth()) + currentDate.getMonth();
	            anomaly.innerHTML = "Project #" + post.lastDepth + " in " + post.tableColumn + ":&emsp;<span class=\"highlightBad\">Overdue by " + monthDiff + " months. Oh dear.</span>";
	        }

	        if (anomaly.innerHTML != "")
	        {
	            summarizeList.appendChild(anomaly);
	        }
	    }

	    console.log(postUsers);
	    console.log(postUsersCounts);

	    // Build priorities & users tables (sort users' names with another array, like don't change the base array, before working with them)
        for(let ind = 0; ind < postPrioritiesCounts.length; ind += 2)
        {
            let newPriorityRow = document.createElement("tr");
            let newPriority1 = document.createElement("td");
	        newPriority1.style.textAlign = "center";
	        newPriority1.innerHTML = priorityValues[ind];
	        let newPriorityCount1 = document.createElement("td");
	        newPriorityCount1.style.textAlign = "center";
	        newPriorityCount1.innerHTML = postPrioritiesCounts[ind];
	        let newPriority2 = document.createElement("td");
	        newPriority2.style.textAlign = "center";
	        newPriority2.innerHTML = priorityValues[ind+1];
	        let newPriorityCount2 = document.createElement("td");
	        newPriorityCount2.style.textAlign = "center";
	        newPriorityCount2.innerHTML = postPrioritiesCounts[ind+1];

	        newPriorityRow.appendChild(newPriority1);
	        newPriorityRow.appendChild(newPriorityCount1);
	        newPriorityRow.appendChild(newPriority2);
	        newPriorityRow.appendChild(newPriorityCount2);
	        prioritiesTable.appendChild(newPriorityRow);
        }

	    let sortedUsers = [...postUsers];
	    sortedUsers.sort();
	    console.log(sortedUsers + "\n\nyippeekeyaheyadeyaaaaa-kayo");
	    console.log(postUsers);

	    for(let ind = 0; ind < sortedUsers.length; ind += 3)
	    {
	        let newUserRow = document.createElement("tr");

            let mappedInd1 = postUsers.indexOf(sortedUsers[ind]);
            //console.log("MI 1 " + mappedInd1);
	        let newUser1 = document.createElement("td");
	        newUser1.style.textAlign = "center";
	        newUser1.innerHTML = sortedUsers[ind];
	        let newUserCount1 = document.createElement("td");
	        newUserCount1.style.textAlign = "center";
	        newUserCount1.innerHTML = postUsersCounts[mappedInd1];
	        newUserRow.appendChild(newUser1);
	        newUserRow.appendChild(newUserCount1);

	        let mappedInd2 = postUsers.indexOf(sortedUsers[ind+1]);
	        //console.log("MI 2 " + mappedInd2);
            let newUser2 = document.createElement("td");
	        newUser2.style.textAlign = "center";
	        newUser2.innerHTML = sortedUsers[ind+1];
	        let newUserCount2 = document.createElement("td");
	        newUserCount2.style.textAlign = "center";
	        newUserCount2.innerHTML = postUsersCounts[mappedInd2];
	        if((sortedUsers.length % 3) == 1 && (sortedUsers.length - ind - 1) < 3)
	        {
	            continue;
	        }
	        newUserRow.appendChild(newUser2);
            newUserRow.appendChild(newUserCount2);

            let mappedInd3 = postUsers.indexOf(sortedUsers[ind+2]);
            //console.log("MI 3 " + mappedInd3);
	        let newUser3 = document.createElement("td");
	        newUser3.style.textAlign = "center";
	        newUser3.innerHTML = sortedUsers[ind+2];
	        let newUserCount3 = document.createElement("td");
	        newUserCount3.style.textAlign = "center";
	        newUserCount3.innerHTML = postUsersCounts[mappedInd3];
	        if((sortedUsers.length % 3) == 2 && (sortedUsers.length - ind - 1) < 3)
	        {
	            continue;
	        }

	        newUserRow.appendChild(newUser3);
            newUserRow.appendChild(newUserCount3);
	        usersTable.appendChild(newUserRow);
	    }

	    let taggedUsers = [];

	    for(let ind = 0; ind < sortedUsers.length; ind++)
	    {
	        // Check for users with many projects.
	        let mappedInd = postUsers.indexOf(sortedUsers[ind]);
	        if(postUsersCounts[mappedInd] >= 3 && taggedUsers.indexOf(sortedUsers[ind]) == -1)
	        {
	            taggedUsers.push(sortedUsers[ind]);

	            let anomaly = document.createElement("li");
	            anomaly.innerHTML = "User: <b>" + sortedUsers[ind] + "</b> has <span class=\"highlightGood\">" + postUsersCounts[mappedInd] + " projects.</span> How are they doing?";
	            summarizeList.appendChild(anomaly);
	        }
	    }

	    // TO DO: Check for things like passed or nearing deadlines, high amounts of high priority projects, high amounts of projects attributed to someone, etc.
	    // Last-minute checks
	    if(postPrioritiesCounts[3] >= 3)
	    {
	        let anomaly = document.createElement("li");
	        anomaly.innerHTML = "Table: There are currently <span class=\"highlightGood\">" + postPrioritiesCounts[3] + " high-priority projects.</span> Best of luck finishing those!";
	        summarizeList.appendChild(anomaly);
	    }

	    if(upcomingPosts >= 3)
	    {
	        let anomaly = document.createElement("li");
	        anomaly.innerHTML = "Table: There are currently <span class=\"highlightGood\">" + upcomingPosts + " projects that are coming up soon.</span>";
	        summarizeList.appendChild(anomaly);
	    }

	    // Create window
	    summarizeWindow.appendChild(summarizeTitle);
	    summarizeWindow.appendChild(summarizeList);
	    summarizeWindow.appendChild(prioritiesTable);
	    summarizeWindow.appendChild(usersTable);

	    summarizeWindow.className = "window";
	    stylizeWindow(summarizeWindow);
        summarizeWindow.style.top = "10%";
        summarizeWindow.style.lineHeight = "1.25";

	}

	// Show the window
	document.getElementById("darkFilter").style.display = "block";
	document.getElementById("summarizeWindow").style.display = "block";

    return;
}

// Submits changes made to the post order and columns for later commits to the database.
// TO DO: This! It'll have to feature a way to enter values for lastDepth, which is superseded by sorting and filtering. (maybe, it's up to you).
// Remember that sorting and filtering are done in Flask, primarily.
function submitChanges()
{
    alert("submit what?\n");
    return;
}

// Brings up a help window featuring information about how to use the site.
function getHelp()
{
    console.log("HELP MEEEE\nHEEEELP");
    createDarkFilter();

    if(document.getElementById("helpWindow") == null)
    {
        let helpWindow = document.createElement("div");
        helpWindow.id = "helpWindow";
        document.body.appendChild(helpWindow);

	    // Window title
	    let helpTitle = document.createElement("h1");
	    helpTitle.id = "helpTitle";
	    helpTitle.style.fontSize = "30px";
	    helpTitle.style.textDecoration = "underline";
	    helpTitle.innerHTML = "How to Use this Site";

	    // It's just a list!
	    let helpList = document.createElement("ul");
	    helpList.id = "helpList";
	    let tips = [
	        "<span class=\"highlightGood\">Hello!</span> This site is a <u>project visualization / kanban board</u>, where you and your team can create and organize \"posts\" of your projects to see where progress is at a glance.\
	        <ul><li>\"Kanban\" originated from Japanese \"kan\", for \"sign\", plus \"ban\", for board, and refers to this usage of cards or posts as visual signals for project status and priority, among other things.</li></ul>",
	        "To begin, <span class=\"highlightGood\">create a post</span> by clicking the column header where you want your project to be sorted under. Doing this opens a window where you can enter information about a project. \
	        Once it's filled and submitted, the page will refresh to show the new post in your chosen column.\
	        <ul><li>Posts need to have a <u>title, priority, tasks, and a user</u>. The deadline can be left blank to default to a week from today.</li>\
	        <li>To cancel creating a post, click anywhere outside the pop-up window.</li>\
	        <li>To <span class=\"highlightGood\">view a post in full</span>, click on it. It's here where you can also edit the post and see notes.</li>",
	        "Posts can be moved around by dragging them over another when they turn fully green. [Update coming soon to make this less strict, as well as to make arrangements permanent!]",
	        "If you want to <span class=\"highlightGood\">sort the posts</span>, click the <span class=\"highlightGood\">\"Filters\"</span> button and select what order you want to sort by.",
	        "By clicking the <span class=\"highlightGood\">\"Summarize Table\"</span> button, you'll see the most pressing parts of the board and its projects neatly compiled for you! This includes overdue or upcoming projects, notices about specific users' workloads,\
	        and counts for projects and users by the amounts of posts they have.",
	        "You've already found it, but click the <span class=\"highlightGood\">\"Help\"</span> button to see these tips again.",
	        "The <span class=\"highlightGood\">\"Submit Changes\"</span> button saves post order after rearrangement. You'll only need to use this if posts get moved. [Update coming to make this relevant!]",
	        "Finally, clicking the gear icon in the lower right shows the <span class=\"highlightGood\">site's settings</span>, which includes column editing, priority editing, etc."
	    ];

	    helpList.style.textAlign = "left";
	    //summarizeList.style.marginLeft = "10%";
	    helpList.style.listStylePosition = "inside";

        for(let tip of tips)
        {
            let newTip = document.createElement("li");
            newTip.innerHTML = tip;
            helpList.appendChild(newTip);
        }

	    helpWindow.className = "window";
	    stylizeWindow(helpWindow);
        //helpWindow.style.top = "10%";
        helpWindow.style.lineHeight = "1.5";
        helpWindow.style.left = "10%";
        helpWindow.style.width = "80%";

        helpWindow.appendChild(helpTitle);
        helpWindow.appendChild(helpList);
    }

    // Show the window
	document.getElementById("darkFilter").style.display = "block";
	document.getElementById("helpWindow").style.display = "block";

    return;
}

// Brings up a settings window featuring table configuration options like column creation, renaming, and deletion, post configuration options like clearing everything,
function getSettings()
{
    alert("Settings for you");
    return;
}



/* [][][] FINAL DISPLAYS [][][] */

// Fill all posts using the queried posts from the database. Namely, replaces the empty posts created during row creation.
function populateAll()
{
    // For some reason, the global variables don't work all that well, at least in terms of the ones with queried values. Maybe it's worth it to write them to a file, but for now this will do.
    queriedColumns = JSON.parse(document.getElementById("queriedColumns").innerHTML).columns;
    queriedPosts = JSON.parse(document.getElementById("queriedPosts").innerHTML).posts;

    // Generic counter to later check against total posts "totalPosts".
    let postsPopulated = 0;

    let currentDepths = [0, 0, 0];

    //console.log(queriedPosts);

    for(let a of queriedPosts)
    {
        // Create each post
        // createPost(a) creates a new post as a div element using the values of the queried post with id "a".
        let newPost = createPost(a);

        //console.log(newPost); This works, it has all the components

        // Place each post
        // Get the post column (referencing the index in columnNames too) for column placement, and the post depth from the inherent value if it has it, or from the current column depth from columnDepths.
        // For each column, find all posts with whose column name matches. Then, populate the post spaces from the top down, going by the last depth if they have it, OR the id (ascending) if not.
        for(let col of queriedColumns)
        {
            if(a.tableColumn == col.name)
            {
                //console.log("column id = " + col.id);
                // Checks if the depth is going over the listed depth of the column, which shouldn't happen. If it does, then bail.
                if(currentDepths[col.id-1] > columnDepths[columnDepths.indexOf(col.name)])
                {
                    console.log("A post tried to be placed after the depth of the column, what happened?");
                    break;
                }
                // Otherwise, carry on by processing the post.
                currentDepths[col.id-1] += 1;
                //console.log(currentDepths);
                //console.log("currentDepths[col.id-1] = " + currentDepths[col.id-1]);

                let postId = "post_" + a.id;
                let targetId = "postSpace_" + currentDepths[col.id-1] + "_" + (columnNames.indexOf(col.name)+1);
                //console.log("Going into " + targetId);
                //console.log(newPost);
                processPost(0, newPost, postId, targetId);
            }
        }

        // Post interaction logic
        let interactablePosts = document.getElementsByClassName("interactablePost");
        for(let post of interactablePosts)
        {
            post.ondragover = (event) => {
                event.preventDefault();
                if(event.target.nodeName == "TABLE")
                {
                    event.target.style.backgroundColor = "#D8FDC5";
                }

            };
            post.ondragleave = (event) => {
                if(event.target.nodeName == "TABLE")
                {
                    event.target.style.backgroundColor = "transparent";
                }
            }
            // Clicking a post opens it in full, showing the whole title, task, datetime, etc.
            post.onclick = (event) => {
                console.log("Clicked " + event.target.id);
                //console.log("Its innerHTML = " + event.target.innerHTML);
                //console.log("Does innerHTML == empty string? " + (event.target.innerHTML == ""));
                // null != "" in JS. Darn.

                createDarkFilter();

                // Since the ID of a post is just a number (ex. 2, 4, 6, 8), you'll have to slice the "post_" off the IDs of posts in here.
                let slicedId = event.target.id.slice(event.target.id.indexOf('_')+1, event.target.id.indexOf('_')+2);
                console.log(slicedId);
                console.log(getPost(slicedId));

                if(document.getElementById("postWindow") == null)
                {
                    let postWindow = document.createElement("div");

                    postWindow.innerHTML = createPost(getPost(slicedId));
                    postWindow.className = "window";
                    stylizeWindow(postWindow);
                    console.log(postWindow.style);
                }
                else
                {
                    document.getElementById("postWindow").innerHTML = createPost(slicedId);
                    console.log(postWindow);
                }

                document.getElementById("darkFilter").style.display = "block";
                document.getElementById("postWindow").style.display = "block";
            }
            post.ondrop = (event) => {
                event.preventDefault();
                event.target.style.backgroundColor = "transparent";
                console.log("ondrop starting!");
                //console.log(event);
                let fromPost = event.dataTransfer.getData("text/html");
                let fromPostId = event.dataTransfer.getData("text/plain");
                //console.log("fromPost has type = " + typeof(fromPost));
                //console.log(event.target);

                let targetAncestor = event.target;
                // Try to get the interactable post parent of the target, which will be an interactable post if the target is part of a post
                try
                {
                    while(targetAncestor.className.indexOf("interactablePost") == -1)
                    {
                        targetAncestor = targetAncestor.parentElement;
                    }
                    console.log("Target's ancestor found: " + targetAncestor.id);
                }
                // If it fails, just disregard everything regarding finding the interactable post.
                catch(err)
                {
                    targetAncestor = event.target;
                    console.log("oh he dead")
                }

                // Initialized interactable posts (dragged over the lower right corner because that's the only part with open space to actually hit this argh)
                // ALL GOOD!
                if(event.target.className.indexOf("interactablePost") != -1 && event.target.innerHTML != "")
                {
                    console.log("Post processing...");
                    console.log("Target post = " + event.target.id);
                    processPost(0, fromPost, fromPostId, event.target.id);
                    console.log("Post processed!\n");
                }
                // Blank interactable posts
                /* Quarantine this for now...
                else if (event.target.className.indexOf("interactablePost") != -1 && event.target.innerHTML == "")
                {
                    console.log("Drawing blanks, I see?");
                    // First, figure out which column the blank post, or the target, is in. If it's in the same column as the dragged post, different processes will need to happen.
                    // If it is in the same column, then "bubble down", swap the target with the post directly under it, until the post directly under it is the blank post.
                    // If not, then do the same "bubbling down", then swap the dragged post with the blank post in the column where the target is.
                    // Finally, check if the dragged post's post space is the last in the column (the first number in the id == maxTableDepth). If so, add a new row with a blank space in the column. createPostRow() will do this if columnDepths has the corresponding depth incremented.

                    // These should be the post spaces, rather than the posts themselves.
                    console.log(event.target);
                    let targetParent = event.target.parentElement;

                    let draggedParent = document.getElementById(fromPostId).parentElement;
                    // So glad the ids were serialized
                    // Next time, though, decide on if you want everything 0-indexed or 1-indexed, just to make things easier
                    let targetCol = targetParent.id.substring(-1);
                    let draggedCol = draggedParent.id.substring(-1);
                    let targetRow = targetParent.id.substring(targetParent.id.indexOf('_')+1, 1);
                    let draggedRow = draggedParent.id.substring(draggedParent.id.indexOf('_')+1, 1);

                    // "Bubble down" the dragged post through its column until it's right above the blank post in that column.
                    for(let a = draggedRow; a <= columnDepths[draggedCol-1]; a++)
                    {
                        let topId = "postSpace_" + a + "_" + draggedCol;
                        //let top = document.getElementById(topId).innerHTML;
                        let top = createPost(topId);
                        let bottomId = "postSpace_" + (a + 1) + "_" + draggedCol;
                        // No need for bottom because only one post is needed in this function
                        console.log("top = " + top);
                        console.log("top id = " + topId);
                        console.log("bottom id = " + bottomId);
                        console.log("bottom = " + document.getElementById(bottomId));
                        processPost(0, top, topId, bottomId);
                    }

                    // Column check; if the target and dragged posts' columns are not the same, swap the dragged post with the blank post in the target column, and readjust column lengths.
                    if(draggedCol != targetCol)
                    {
                        columnDepths[targetCol-1]++;
                        createPostRow();
                        console.log("Skarmory!");
                        processPost(0, fromPost, fromPostId, event.target.id);
                        // If this swaps a blank and a full post, delete the second blank of the column after the swap.
                        let blankId = "postSpace_" + (columnDepths[draggedCol-1] + 1) + "_" + draggedCol;
                        document.removeChild(document.getElementById(blankId));
                    }
                }
                */
                // Elements of initialized interactable posts
                // NOTE: This and the the prior "else if" statement can be consolidated into one, provided they produce the same output.
                // TO DO: Fix this. I'm quarantining it for now since it doesn't really work all that well. Yet.
                /*else if (targetAncestor.className.indexOf("interactablePost") != -1)
                {
                    console.log("I can't aim!");
                    // Get the post element's space.
                    let target = event.target.parentElement;
                    console.log(target);
                    while(target.className.indexOf("postSpace") == -1)
                    {
                        target = target.parentElement;
                    }
                    console.log("target's id = " + target.id);
                    let draggedParent = document.getElementById(fromPostId).parentElement;
                    console.log(document.getElementById(fromPostId));
                    console.log("draggedParent's id = " + draggedParent.id);
                    let targetCol = target.id.slice(target.id.length-1, target.id.length);
                    let draggedCol = draggedParent.id.slice(draggedParent.id.length-1, draggedParent.id.length);
                    let targetRow = target.id.slice(target.id.indexOf('_')+1, target.id.indexOf('_')+2);
                    let draggedRow = draggedParent.id.slice(draggedParent.id.indexOf('_')+1, draggedParent.id.indexOf('_')+2);
                    console.log(targetCol + " " + targetRow);
                    console.log(draggedCol + " " + draggedRow);


                    // "Bubble down" the dragged post through its column until it's right above the blank post in that column.
                    for(let a = draggedRow; a <= columnDepths[draggedCol-1]; a++)
                    {
                        /*let topId = "postSpace_" + a + "_" + draggedCol;
                        let top = document.getElementById(topId);

                        //let topId = "post_" +

                        console.log(top);
                        let topWrap = document.createElement("table");
                        topWrap.innerHTML = top;
                        let bottomRow = Number(a)+1;
                        console.log("bottomRow = " + bottomRow);
                        let bottomId = "postSpace_" + bottomRow + "_" + draggedCol;
                        console.log("Top = " + topId + "\nBottom = " + bottomId);
                        // No need for bottom because only one post is needed in this function
                        processPost(0, topWrap, topId, bottomId);



                        let topId = "postSpace_" + a + "_" + draggedCol;
                        let top = document.getElementById(topId);
                        console.log(top)
                        let bottomRow = Number(a) + 1;
                        let bottomId = "postSpace_" + bottomRow + "_" + draggedCol;
                        // Swap a post and the one directly under it.
                        // So, you'll want to call createPost to do this, since that formats everything.
                        processPost(0, top, topId, bottomId)
                    }

                    // Column check; if the target and dragged posts' columns are not the same, swap the dragged post with the blank post in the target column, and readjust column lengths.
                    if(draggedCol != targetCol)
                    {
                        columnDepths[targetCol-1]++;
                        createPostRow();
                        processPost(0, fromPost, fromPostId, event.target.id);
                        // If this swaps a blank and a full post, delete the second blank of the column after the swap.
                        let blankId = "postSpace_" + (columnDepths[draggedCol-1] + 1) + "_" + draggedCol;
                        document.removeChild(document.getElementById(blankId));
                    }
                }*/
                else
                {
                    console.log("This HTML element isn't interactable, sorry...");
                }
            };

            // Posts become draggable if they're populated; if they're a blank space, they can only be dropped into.
            if(post.className.indexOf("interactablePost") != -1 && post.innerHTML != "")
            {
                post.ondragstart = (event) => {
                    console.log("ondragstart starting!");
                    //console.log(event);
                    event.dataTransfer.setData("text/html", event.target.innerHTML);
                    event.dataTransfer.setData("text/plain", event.target.id);
                    //event.dataTransfer.setData("text/html", "<img src=\"static/very_important.gif\">");
                    console.log("ondragstart completed!");
                };
                post.draggable = "true";
            }
        }

        postsPopulated++;
    }
    console.log("Board populated with " + postsPopulated + " posts!");
	return;
}

// Creates pretty much everything on the site while formatting it.
function formatAll()
{
	//Format sidebar/banner
	//if(size is greater than some threshold hmm)
	//document.getElementById("filterTable").style.width = "100px";
	document.getElementById("filterTable").style.height = "10%";
	//document.getElementById("summarizeTable").style.width = "100px";
	document.getElementById("summarizeTable").style.height = "10%";
	//document.getElementById("help").style.width = "100px";
	document.getElementById("help").style.height = "10%";
	//document.getElementById("submitChanges").style.width = "100px";
	document.getElementById("submitChanges").style.height = "10%";

	formatAsColumns("columnHeader");

	// Make as many rows as there are posts in the longest column.
	// So, these parsed JSON objects have attributes instead of elements, which makes sense, I guess. They aren't lists in that usual list manipulation and navigation doesn't work, but they act like lists in that they hold data.
	queriedColumns = JSON.parse(document.getElementById("queriedColumns").innerHTML).columns;
    //console.log("queriedColumns is type: " + typeof(queriedColumns));
    //console.log("queriedColumns has the following attributes: " + Object.keys(queriedColumns));
    console.log(queriedColumns);
    numColumns = queriedColumns.length;
    queriedPosts = JSON.parse(document.getElementById("queriedPosts").innerHTML).posts;
    //console.log("queriedPosts is type: " + typeof(queriedPosts));
    //console.log("queriedPosts has the following attributes: " + Object.keys(queriedPosts));
    console.log(queriedPosts);
    totalPosts = queriedPosts.length;

    // Get column names and depths.
    for(let col of queriedColumns)
    {
        columnNames.push(col.name);
        columnDepths.push(col.depth);
    }
    console.log("The present columns are: " + columnNames);
    console.log("Their depths are: " + columnDepths);
    // Max table depth is 1 over the max column depth to allow for a final interactable post space in the longest column.
    maxTableDepth = Math.max(...columnDepths) + 1;

	for(let a = numRows; a < maxTableDepth; a++)
	{
		console.log("Row " + (a+1) + "\n");
		createPostRow();
	}
	formatAsColumns("postSpace");

    console.log("All clear");
    populateAll();
    console.log("All clear, ma'am");

	return;
}




